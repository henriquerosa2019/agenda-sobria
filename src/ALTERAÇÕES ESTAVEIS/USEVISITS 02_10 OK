// src/hooks/useVisits.ts
import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabaseClient";

export interface Visit {
  id: string;
  date: string | null;
  time: string | null;
  location?: { id: string; name: string; address?: string | null };
  companions?: { id: string; name: string }[];
  observation?: string | null;

  startTime?: string | null;
  endTime?: string | null;
  isFinalized?: boolean;
}

function onlyDate(v?: string | null): string | null {
  if (!v) return null;
  const s = String(v);
  // "2025-10-31T00:00:00" -> "2025-10-31"
  return s.includes("T") ? s.slice(0, 10) : s;
}
function onlyTime(v?: string | null): string | null {
  if (!v) return null;
  const s = String(v);
  // "19:30:00" -> "19:30"
  return s.slice(0, 5);
}

function normalizeVisit(dbRow: any): Visit {
  const companions: { id: string; name: string }[] = Array.isArray(dbRow?.visit_companions)
    ? dbRow.visit_companions
        .map((vc: any) => vc?.companions)
        .filter(Boolean)
        .map((c: any) => ({ id: String(c.id), name: c.name }))
    : [];

  const loc = dbRow?.locations
    ? {
        id: String(dbRow.locations.id),
        name: dbRow.locations.name,
        address: dbRow.locations.address ?? null,
      }
    : undefined;

  return {
    id: String(dbRow.id),
    date: onlyDate(dbRow.date),
    time: onlyTime(dbRow.time),
    location: loc,
    companions,
    observation: dbRow.notes ?? null,
  };
}

export default function useVisits() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  // --------- Carregar visitas ----------
  useEffect(() => {
    (async () => {
      await fetchVisits();
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  async function fetchVisits() {
    setIsLoading(true);
    try {
      // Atenção: use o nome de relação "locations:location_id"
      // e "visit_companions(companions(...))"
      const { data, error } = await supabase
        .from("visits")
        .select(
          `
          id,
          date,
          time,
          notes,
          location_id,
          locations:location_id (
            id,
            name,
            address
          ),
          visit_companions (
            companions ( id, name )
          )
        `
        )
        .order("date", { ascending: true })
        .order("time", { ascending: true });

      if (error) {
        console.warn("Erro ao carregar visitas:", error.message);
        return;
      }
      const list = Array.isArray(data) ? data.map(normalizeVisit) : [];
      setVisits(list);
    } finally {
      setIsLoading(false);
    }
  }

  // --------- Atualiza localmente (no estado) ----------
  function updateVisit(id: string, patch: Partial<Visit>) {
    setVisits((prev) =>
      prev.map((v) => (String(v.id) === String(id) ? { ...v, ...patch } : v))
    );
  }

  // --------- Garantir companheiros e obter IDs ----------
  async function ensureCompanionsExist(names: string[]): Promise<string[]> {
    const clean = (names || [])
      .map((n) => String(n).trim())
      .filter(Boolean);

    if (clean.length === 0) return [];

    const { data: existing, error: selErr } = await supabase
      .from("companions")
      .select("id, name");

    if (selErr) {
      console.warn("[companions] Erro ao buscar companheiros:", selErr.message);
      return [];
    }

    const existingMap = new Map(
      (existing || []).map((c) => [String(c.name).trim().toLowerCase(), String(c.id)])
    );

    const toInsert = clean.filter((n) => !existingMap.has(n.toLowerCase()));

    let newIds: string[] = [];
    if (toInsert.length > 0) {
      const { data: inserted, error: insErr } = await supabase
        .from("companions")
        .insert(toInsert.map((n) => ({ name: n })))
        .select("id, name");

      if (insErr) {
        console.warn("[companions] Erro ao inserir novos companheiros:", insErr.message);
      } else {
        newIds = (inserted || []).map((c: any) => String(c.id));
        for (const c of inserted || []) {
          existingMap.set(String(c.name).trim().toLowerCase(), String(c.id));
        }
      }
    }

    // monta lista final de IDs na ordem recebida
    const allIds = clean
      .map((n) => existingMap.get(n.toLowerCase()))
      .filter(Boolean) as string[];

    return allIds.length > 0 ? allIds : newIds;
  }

  // --------- Salvar mudanças de uma visita ----------
  // observation -> salva na coluna notes
  // date/time -> atualiza se fornecidos
  // companions -> sincroniza
  async function saveVisitChanges(
    id: string,
    observation: string,
    companionNames: string[],
    date?: string | null,
    time?: string | null
  ) {
    // normalização
    const normDate =
      typeof date === "string" && date ? (date.includes("T") ? date.slice(0, 10) : date) : undefined;
    const normTime =
      typeof time === "string" && time ? time.slice(0, 5) : undefined;

    // payload dinâmico para não jogar null em colunas NOT NULL sem necessidade
    const payload: Record<string, any> = { notes: observation ?? null };
    if (normDate !== undefined) payload.date = normDate;
    if (normTime !== undefined) payload.time = normTime;

    const { error: updErr } = await supabase
      .from("visits")
      .update(payload)
      .eq("id", id);

    if (updErr) {
      console.warn("[saveVisitChanges] Erro ao atualizar visita:", updErr.message);
      return;
    }

    // sincroniza companheiros
    const compIds = await ensureCompanionsExist(companionNames);

    // apaga ligações antigas
    await supabase.from("visit_companions").delete().eq("visit_id", id);

    if (compIds.length > 0) {
      const payloadComp = compIds.map((companion_id) => ({
        visit_id: id,
        companion_id,
      }));
      const { error: insErr } = await supabase
        .from("visit_companions")
        .insert(payloadComp);

      if (insErr) {
        console.warn("[saveVisitChanges] Erro ao inserir companheiros:", insErr.message);
      }
    }
  }

  // --------- Criar nova visita ----------
  async function createNewVisit(params: {
    date: string;
    time: string;
    location_id: string;
    observation?: string;
    companionNames?: string[];
  }) {
    const normDate = onlyDate(params.date) || null;
    const normTime = onlyTime(params.time) || null;

    const { data, error } = await supabase
      .from("visits")
      .insert([
        {
          date: normDate,
          time: normTime,
          location_id: params.location_id,
          notes: params.observation ?? null,
        },
      ])
      .select("id")
      .single();

    if (error || !data?.id) {
      console.warn("[createNewVisit] Erro ao criar visita:", error?.message);
      return;
    }

    const visitId = String(data.id);

    // companheiros
    const compIds = await ensureCompanionsExist(params.companionNames || []);
    if (compIds.length > 0) {
      const payload = compIds.map((companion_id) => ({
        visit_id: visitId,
        companion_id,
      }));
      await supabase.from("visit_companions").insert(payload);
    }

    // refetch para refletir a inclusão
    await fetchVisits();
  }

  return {
    isLoading,
    visits,

    fetchVisits,
    updateVisit,
    saveVisitChanges,
    createNewVisit,
  };
}
